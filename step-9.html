<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
  <title>WebRTC Practice</title>
</head>

<body class="bg-gray-50 dark:bg-gray-950">
  <header>
    <nav
      class="flex items-center justify-between w-full relative max-w-2xl border-gray-200 dark:border-gray-700 mx-auto pt-8 pb-8 sm:pb-16 text-gray-900 bg-gray-50 dark:bg-gray-950 bg-opacity-60 dark:text-gray-100">
      <div class="flex justify-center items-center gap-3">
        <a href="step-1.html"
          class="cursor-pointer font-normal text-gray-600 dark:text-gray-400 rounded-lg hover:text-gray-950 dark:hover:text-gray-200 transition-all">
          <span class="capsize">Step-1</span>
        </a>
        <a href="step-2.html"
          class="cursor-pointer font-normal text-gray-600 dark:text-gray-400 rounded-lg hover:text-gray-950 dark:hover:text-gray-200 transition-all">
          <span class="capsize">Step-2</span>
        </a>
        <a href="step-3.html"
          class="cursor-pointer font-normal text-gray-600 dark:text-gray-400 rounded-lg hover:text-gray-950 dark:hover:text-gray-200 transition-all">
          <span class="capsize">Step-3</span>
        </a>
        <a href="step-6.html"
          class="cursor-pointer font-normal text-gray-600 dark:text-gray-400 rounded-lg hover:text-gray-950 dark:hover:text-gray-200 transition-all">
          <span class="capsize">Step-6</span>
        </a>
        <a href="step-7.html"
          class="cursor-pointer font-normal text-gray-600 dark:text-gray-400 rounded-lg hover:text-gray-950 dark:hover:text-gray-200 transition-all">
          <span class="capsize">Step-7</span>
        </a>
        <a href="step-8.html"
          class="cursor-pointer font-normal text-gray-600 dark:text-gray-400 rounded-lg hover:text-gray-950 dark:hover:text-gray-200 transition-all">
          <span class="capsize">Step-8</span>
        </a>
        <a href="step-9.html"
          class="cursor-pointer font-normal text-gray-600 dark:text-gray-400 rounded-lg hover:text-gray-950 dark:hover:text-gray-200 transition-all">
          <span class="capsize">Step-9</span>
        </a>
        <a href="step-10.html"
          class="cursor-pointer font-normal text-gray-600 dark:text-gray-400 rounded-lg hover:text-gray-950 dark:hover:text-gray-200 transition-all">
          <span class="capsize">Step-10</span>
        </a>
      </div>
    </nav>
  </header>

  <main class="flex flex-col justify-center items-center">
    <div id="video-streams" class="flex justify-center"></div>
    <h2>Local WebRTC Video Call</h2>
    <div class="p-3 w-full flex justify-center gap-8">
      <video id="localVideo" class="max-w-60" autoplay playsinline controls></video>
      <video id="remoteVideo" class="max-w-60" autoplay playsinline controls></video>
    </div>

    <div class="p-3 flex justify-center gap-4">
      <button id="videoButton" onclick="toggleVideo()" type="button"
        class="cursor-pointer px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-500 focus:ring-4 focus:ring-indigo-500">Stop
        Video</button>
      <button id="muteButton" onclick="toggleAudio()" type="button"
        class="cursor-pointer px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-500 focus:ring-4 focus:ring-indigo-500">Mute</button>
      <button onclick="startCall()" type="button"
        class="cursor-pointer px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-500 focus:ring-4 focus:ring-indigo-500">Start
        Call</button>
      <button onclick="hangUp()" type="button"
        class="cursor-pointer px-4 py-2 bg-red-600 text-white rounded hover:bg-red-500 focus:ring-4 focus:ring-red-500">Hang
        Up</button>
      <button onclick="attemptReconnection()" type="button"
        class="cursor-pointer px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-500 focus:ring-4 focus:ring-indigo-500">Reconnect</button>
      <button onclick="startScreenShare()" type="button"
        class="cursor-pointer px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-500 focus:ring-4 focus:ring-purple-500">Share
        Screen</button>
      <button onclick="stopScreenShare()" type="button"
        class="cursor-pointer px-4 py-2 bg-red-600 text-white rounded hover:bg-red-500 focus:ring-4 focus:ring-red-500">Stop
        Sharing</button>
      <button id="startRecording" type="button"
        class="cursor-pointer px-4 py-2 bg-lime-600 text-white rounded hover:bg-lime-500 focus:ring-4 focus:ring-lime-500">Start
        Recording</button>
      <button id="stopRecording" type="button"
        class="cursor-pointer px-4 py-2 bg-lime-600 text-white rounded hover:bg-lime-500 focus:ring-4 focus:ring-lime-500">Stop
        & Download</button>
    </div>
  </main>
</body>

<script src="https://cdn.socket.io/4.4.1/socket.io.min.js"></script>
<script>
  /**
   * @logic for initializing the call
   * 1. connect to the socket server
   * 2. once connected to start the call, click the start call button, it will set your local video stream to video element, then it will create a peer connection, then add the local video stream to the peer connection, then send ice candidates to the server, then create offer, then send offer to the server
   * 3. when you receive the offer, set it to the peer connection, then create answer, then send answer to the server
   * 4. when you receive the answer, set it to the peer connection, then add ice candidates to the peer connection
   * 
   */
  const socket = io("http://192.168.0.100:3000");
  let localStream, remoteStream;
  let peerConnection;
  const servers = {
    iceServers: [{
      urls: "stun:stun.l.google.com:19302"
    }]
  };
  let mediaRecorder;
  let recordedChunks = [];

  async function startCall() {
    try {
      localStream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true
      });
      document.getElementById("localVideo").srcObject = localStream;

      peerConnection = new RTCPeerConnection(servers);
      localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

      peerConnection.onicecandidate = event => {
        if (event.candidate) socket.emit("ice-candidate", event.candidate);
      };

      peerConnection.ontrack = event => {
        remoteStream = event.streams[0];
        document.getElementById("remoteVideo").srcObject = event.streams[0];
      };

      peerConnection.oniceconnectionstatechange = () => {
        if (peerConnection.iceConnectionState === "disconnected") {
          console.warn("Peer disconnected! Attempting to reconnect...");
          attemptReconnection();
        }
      };

      peerConnection.onconnectionstatechange = () => {
        if (peerConnection.connectionState === "failed") {
          console.error("Connection failed! Resetting...");
          restartConnection();
        }
      };

      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      socket.emit("offer", offer);
    } catch (error) {
      alert(error.message);
    }
  }

  function startRecording(stream) {
    mediaRecorder = new MediaRecorder(stream);
    mediaRecorder.ondataavailable = event => {
      if (event.data.size > 0) recordedChunks.push(event.data);
    };
    mediaRecorder.onstop = saveRecording;
    mediaRecorder.start();
  }

  function saveRecording() {
    const blob = new Blob(recordedChunks, {
      type: "video/webm"
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "recording.webm";
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(url);
  }

  function mergeStreams(localStream, remoteStream) {
    const combinedStream = new MediaStream();
    localStream.getTracks().forEach(track => combinedStream.addTrack(track));
    remoteStream.getTracks().forEach(track => combinedStream.addTrack(track));
    return combinedStream;
  }

  document.getElementById("startRecording").onclick = () => {
    const mixedStream = mergeStreams(localStream, remoteStream);
    startRecording(mixedStream);
  };

  document.getElementById("stopRecording").onclick = () => mediaRecorder.stop();


  async function startScreenShare() {
    try {
      const screenStream = await navigator.mediaDevices.getDisplayMedia({
        video: true
      });
      const screenTrack = screenStream.getVideoTracks()[0];

      const sender = peerConnection.getSenders().find(s => s.track.kind === "video");
      sender.replaceTrack(screenTrack);

      screenTrack.onended = () => {
        stopScreenShare();
      };
    } catch (error) {
      console.error("Screen sharing error:", error);
    }
  }

  async function stopScreenShare() {
    try {
      const cameraStream = await navigator.mediaDevices.getUserMedia({
        video: true
      });
      const cameraTrack = cameraStream.getVideoTracks()[0];

      const sender = peerConnection.getSenders().find(s => s.track.kind === "video");
      sender.replaceTrack(cameraTrack);
    } catch (error) {
      console.error("Error switching back to camera:", error);
    }
  }

  async function attemptReconnection() {
    if (!peerConnection || peerConnection.iceConnectionState === "closed") return;

    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    socket.emit("reconnect-offer", offer);
  }

  function restartConnection() {
    if (peerConnection) {
      peerConnection.close();
      peerConnection = null;
    }
    startCall();
  }

  function toggleAudio() {
    const localVideo = document.getElementById("localVideo");
    const audioTrack = localStream.getAudioTracks()[0];
    audioTrack.enabled = !audioTrack.enabled;
    localVideo.muted = !localVideo.muted;
    document.getElementById("muteButton").innerText = audioTrack.enabled ? "Mute" : "Unmute";
  }

  function toggleVideo() {
    const localVideo = document.getElementById("localVideo");
    const videoTrack = localStream.getVideoTracks()[0];
    videoTrack.enabled ? localVideo.pause() : localVideo.play();
    videoTrack.enabled = !videoTrack.enabled;
    document.getElementById("videoButton").innerText = videoTrack.enabled ? "Stop Video" : "Start Video";
  }

  function hangUp() {
    peerConnection.close();
    peerConnection = null;

    localStream.getTracks().forEach(track => track.stop());
    document.getElementById("localVideo").srcObject = null;
    document.getElementById("remoteVideo").srcObject = null;

    socket.emit("hang-up");
  }

  socket.on("reconnect-offer", async (offer) => {
    if (!peerConnection) return;

    await peerConnection.setRemoteDescription(offer);
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);
    socket.emit("reconnect-answer", answer);
  });

  socket.on("reconnect-answer", async (answer) => {
    if (!peerConnection) return;
    await peerConnection.setRemoteDescription(answer);
  });

  socket.on("offer", async (offer) => {
    if (!localStream) return alert(
      "Someone has already started the call. To get started, click the Start Call button");
    // peerConnection = new RTCPeerConnection(servers);
    // localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

    // peerConnection.onicecandidate = event => {
    //   if (event.candidate) socket.emit("ice-candidate", event.candidate);
    // };

    // peerConnection.ontrack = event => {
    // remoteStream = event.streams[0];
    //   document.getElementById("remoteVideo").srcObject = event.streams[0];
    // };

    await peerConnection.setRemoteDescription(offer);
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);
    socket.emit("answer", answer);
  });

  socket.on("answer", async (answer) => {
    await peerConnection.setRemoteDescription(answer);
  });

  socket.on("ice-candidate", async (candidate) => {
    if (!localStream) return
    await peerConnection.addIceCandidate(candidate);
  });

  socket.on("hang-up", () => {
    if (peerConnection) {
      peerConnection.close();
      peerConnection = null;
    }

    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      document.getElementById("localVideo").srcObject = null;
      document.getElementById("remoteVideo").srcObject = null;
    }
  });
</script>

</html>